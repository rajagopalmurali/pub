name: Deploy PHP App to AWS EC2

on:
  workflow_dispatch:  # Manual trigger
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  AWS_REGION: ap-south-1
  INSTANCE_TYPE: t2.micro
  KEY_NAME: github-actions-php-key
  AMI_ID: ami-02d26659fd82cf299

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Create security group
      id: security-group
      run: |
        # Create security group for SSH and web access
        SG_ID=$(aws ec2 create-security-group \
          --group-name php-app-sg \
          --description "Security group for PHP app" \
          --region ${{ env.AWS_REGION }} \
          --query 'GroupId' \
          --output text 2>/dev/null || \
          aws ec2 describe-security-groups \
          --group-names php-app-sg \
          --region ${{ env.AWS_REGION }} \
          --query 'SecurityGroups[0].GroupId' \
          --output text)
        
        echo "sg_id=$SG_ID" >> $GITHUB_OUTPUT
        
        # Add SSH rule (port 22)
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 22 \
          --cidr 0.0.0.0/0 \
          --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        # Add HTTP rule (port 80)
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 80 \
          --cidr 0.0.0.0/0 \
          --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        # Add HTTPS rule (port 443)
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 443 \
          --cidr 0.0.0.0/0 \
          --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        # Add MySQL rule (port 3306) - only for local access
        aws ec2 authorize-security-group-ingress \
          --group-id $SG_ID \
          --protocol tcp \
          --port 3306 \
          --source-group $SG_ID \
          --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        echo "Security group $SG_ID configured with SSH, HTTP, HTTPS, and MySQL access"
        
    - name: Create or get key pair
      id: key-pair
      run: |
        # Delete existing key pair if it exists
        aws ec2 delete-key-pair \
          --key-name ${{ env.KEY_NAME }} \
          --region ${{ env.AWS_REGION }} 2>/dev/null || true
        
        # Create new key pair with proper format
        aws ec2 create-key-pair \
          --key-name ${{ env.KEY_NAME }} \
          --query 'KeyMaterial' \
          --output text \
          --region ${{ env.AWS_REGION }} > ${{ env.KEY_NAME }}.pem
        
        # Ensure proper line endings and format
        sed -i 's/\r$//' ${{ env.KEY_NAME }}.pem
        
        # Verify key file was created and has content
        if [ ! -s "${{ env.KEY_NAME }}.pem" ]; then
          echo "Error: Key file is empty or not created"
          exit 1
        fi
        
        # Set proper permissions for the key file
        chmod 400 ${{ env.KEY_NAME }}.pem
        
        # Fix ownership and permissions for SSH client
        chown runner:docker ${{ env.KEY_NAME }}.pem
        chmod 600 ${{ env.KEY_NAME }}.pem
        
        # Verify key file permissions
        ls -la ${{ env.KEY_NAME }}.pem
        
        # Verify SSH client can read the key
        echo "Verifying SSH client can read key..."
        if ssh-keygen -l -f "${{ env.KEY_NAME }}.pem" > /dev/null 2>&1; then
          echo "✓ SSH client can read the key"
        else
          echo "✗ SSH client cannot read the key"
          exit 1
        fi
        
        echo "Key pair created successfully: ${{ env.KEY_NAME }}.pem"
        
    - name: Launch EC2 instance
      id: launch-instance
      run: |
        # Launch EC2 instance with custom security group
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id ${{ env.AMI_ID }} \
          --count 1 \
          --instance-type ${{ env.INSTANCE_TYPE }} \
          --key-name ${{ env.KEY_NAME }} \
          --security-group-ids ${{ steps.security-group.outputs.sg_id }} \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=PHP-App},{Key=Project,Value=GitHubActions}]' \
          --query 'Instances[0].InstanceId' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
        
        # Wait for instance to be running
        echo "Waiting for instance $INSTANCE_ID to be running..."
        aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region ${{ env.AWS_REGION }}
        
        # Get public IP
        PUBLIC_IP=$(aws ec2 describe-instances \
          --instance-ids $INSTANCE_ID \
          --query 'Reservations[0].Instances[0].PublicIpAddress' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
        echo "Instance $INSTANCE_ID is running with public IP: $PUBLIC_IP"
        
    - name: Wait for SSH access
      run: |
        # Wait for SSH to be available
        echo "Waiting for SSH access..."
        echo "Using key file: ${{ env.KEY_NAME }}.pem"
        echo "Connecting to: ubuntu@${{ steps.launch-instance.outputs.public_ip }}"
        
        # Debug: Check key file
        echo "=== KEY FILE DEBUG INFO ==="
        echo "Current directory: $(pwd)"
        echo "Key file path: ${{ env.KEY_NAME }}.pem"
        echo "Key file exists: $(ls -la ${{ env.KEY_NAME }}.pem 2>/dev/null || echo 'NO')"
        
        if [ -f "${{ env.KEY_NAME }}.pem" ]; then
          echo "Key file size: $(wc -c < ${{ env.KEY_NAME }}.pem) bytes"
          echo "Key file permissions: $(ls -la ${{ env.KEY_NAME }}.pem)"
          echo "Key file header (first line):"
          head -n 1 ${{ env.KEY_NAME }}.pem
        else
          echo "ERROR: Key file does not exist!"
        fi
        echo "=== END KEY FILE DEBUG ==="
        
        for i in {1..30}; do
          echo "Attempt $i: Trying SSH connection..."
          
          # Try SSH with absolute path
          KEY_PATH="$(pwd)/${{ env.KEY_NAME }}.pem"
          echo "Using key path: $KEY_PATH"
          
          if ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i "$KEY_PATH" ubuntu@${{ steps.launch-instance.outputs.public_ip }} "echo 'SSH ready'"; then
            echo "SSH access confirmed"
            break
          fi
          echo "Attempt $i: SSH failed, waiting 10 seconds..."
          sleep 10
        done
        
    - name: Deploy PHP application
      run: |
        # Create deployment script
        cat > deploy-php.sh << 'DEPLOY_SCRIPT_EOF'
        #!/bin/bash
        set -e
        
        echo "Starting PHP application deployment..."
        
        # Update system
        sudo apt update -y
        
        # Install PHP 8.1 and required extensions
        sudo apt install -y software-properties-common
        sudo add-apt-repository ppa:ondrej/php -y
        sudo apt update -y
        sudo apt install -y php8.1 php8.1-fpm php8.1-mysql php8.1-xml php8.1-curl php8.1-mbstring php8.1-zip php8.1-gd php8.1-cli php8.1-common
        
        # Install nginx
        sudo apt install -y nginx
        
        # Install MySQL
        sudo apt install -y mysql-server
        
        # Start and enable services
        sudo systemctl start nginx
        sudo systemctl enable nginx
        sudo systemctl start mysql
        sudo systemctl enable mysql
        sudo systemctl start php8.1-fpm
        sudo systemctl enable php8.1-fpm
        
        # Secure MySQL installation for MySQL 8.0+
        echo "Securing MySQL installation..."
        
        # Wait for MySQL to be fully ready
        sleep 10
        
        # Try to access MySQL with sudo (no password needed for root with sudo)
        if sudo mysql -e "SELECT 1;" > /dev/null 2>&1; then
          echo "MySQL is accessible via sudo"
          
          # Create a temporary root password file for secure access
          echo "Creating temporary MySQL root access..."
          sudo mysql -e "ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'temp_root_pass_123';"
          
          # Now use the password to secure the installation
          sudo mysql -u root -ptemp_root_pass_123 -e "DELETE FROM mysql.user WHERE User='';"
          sudo mysql -u root -ptemp_root_pass_123 -e "DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');"
          sudo mysql -u root -ptemp_root_pass_123 -e "DROP DATABASE IF EXISTS test;"
          sudo mysql -u root -ptemp_root_pass_123 -e "DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';"
          sudo mysql -u root -ptemp_root_pass_123 -e "FLUSH PRIVILEGES;"
          
          # Create database and user for the application
          echo "Creating database and user..."
          sudo mysql -u root -ptemp_root_pass_123 -e "CREATE DATABASE IF NOT EXISTS php_app_db;"
          sudo mysql -u root -ptemp_root_pass_123 -e "CREATE USER IF NOT EXISTS 'php_user'@'localhost' IDENTIFIED BY 'php_password_123';"
          sudo mysql -u root -ptemp_root_pass_123 -e "GRANT ALL PRIVILEGES ON php_app_db.* TO 'php_user'@'localhost';"
          sudo mysql -u root -ptemp_root_pass_123 -e "FLUSH PRIVILEGES;"
          
          # Remove temporary root password (optional security measure)
          # sudo mysql -u root -ptemp_root_pass_123 -e "ALTER USER 'root'@'localhost' IDENTIFIED WITH auth_socket;"
          
        else
          echo "MySQL is not accessible, trying alternative approach..."
          
          # Alternative approach: use mysql_secure_installation script
          echo "Running mysql_secure_installation..."
          sudo mysql_secure_installation << MYSQL_SECURE_EOF
        y
        y
        y
        y
        y
        y
        MYSQL_SECURE_EOF
          
          # Try to create database and user after securing
          sleep 5
          if sudo mysql -u root -e "SELECT 1;" > /dev/null 2>&1; then
            sudo mysql -e "CREATE DATABASE IF NOT EXISTS php_app_db;"
            sudo mysql -e "CREATE USER IF NOT EXISTS 'php_user'@'localhost' IDENTIFIED BY 'php_password_123';"
            sudo mysql -e "GRANT ALL PRIVILEGES ON php_app_db.* TO 'php_user'@'localhost';"
            sudo mysql -e "FLUSH PRIVILEGES;"
          fi
        fi
        
        # Create app directory and clean it if it exists
        echo "Setting up application directory..."
        if [ -d "/var/www/html" ]; then
          echo "Directory /var/www/html exists, cleaning it..."
          sudo rm -rf /var/www/html/*
          sudo rm -rf /var/www/html/.* 2>/dev/null || true
        else
          echo "Creating directory /var/www/html..."
          sudo mkdir -p /var/www/html
        fi
        
        sudo chown ubuntu:ubuntu /var/www/html
        sudo chmod 755 /var/www/html
        
        # Clone repository
        echo "Cloning repository..."
        cd /var/www/html
        
        # Verify directory is empty before cloning
        if [ "$(ls -A)" ]; then
          echo "ERROR: Directory is not empty after cleaning!"
          ls -la
          exit 1
        fi
        
        echo "Directory is empty, proceeding with clone..."
        
        # Try to clone with retry mechanism
        MAX_RETRIES=3
        for attempt in $(seq 1 $MAX_RETRIES); do
          echo "Clone attempt $attempt of $MAX_RETRIES..."
          if git clone https://github.com/${{ github.repository }}.git .; then
            echo "Git clone successful on attempt $attempt"
            break
          else
            echo "Git clone failed on attempt $attempt"
            if [ $attempt -eq $MAX_RETRIES ]; then
              echo "ERROR: Git clone failed after $MAX_RETRIES attempts!"
              echo "Trying alternative approach..."
              
              # Alternative: download as ZIP
              echo "Downloading repository as ZIP..."
              curl -L "https://github.com/${{ github.repository }}/archive/refs/heads/main.zip" -o repo.zip
              if [ -f "repo.zip" ]; then
                unzip repo.zip
                # Move contents from the extracted folder
                mv */.* . 2>/dev/null || true
                mv */* . 2>/dev/null || true
                rm -rf repo.zip */
                echo "Repository extracted from ZIP"
              else
                echo "ERROR: Could not download repository as ZIP either!"
                exit 1
              fi
            fi
            sleep 5
          fi
        done
        
        # Verify clone was successful
        if [ ! -d ".git" ] && [ ! -f "composer.json" ] && [ ! -f "index.php" ]; then
          echo "ERROR: Repository setup failed completely!"
          ls -la
          exit 1
        fi
        
        echo "Repository cloned successfully!"
        echo "Repository contents:"
        ls -la
        
        # Detect application type
        echo "=== APPLICATION TYPE DETECTION ==="
        if [ -f "artisan" ]; then
          echo "✓ Laravel application detected (artisan file found)"
        elif [ -f "composer.json" ]; then
          echo "✓ Composer-based PHP application detected"
        elif [ -f "index.php" ]; then
          echo "✓ Standard PHP application detected (index.php found)"
        elif [ -f ".env.example" ]; then
          echo "✓ Environment-based PHP application detected"
        else
          echo "⚠️  Unknown application type - no standard PHP files detected"
          echo "Available files:"
          find . -maxdepth 1 -type f | head -20
        fi
        echo "================================="
        
        # Check if we have the expected files
        if [ ! -f "composer.json" ] && [ ! -f "index.php" ] && [ ! -f ".env.example" ]; then
          echo "WARNING: Repository doesn't contain expected PHP application files"
          echo "This might be a different type of repository or the clone didn't work properly"
          echo "Continuing anyway..."
        fi
        
        # Install Composer if not exists
        if [ ! -f "/usr/local/bin/composer" ]; then
          echo "Installing Composer..."
          curl -sS https://getcomposer.org/installer | sudo php -- --install-dir=/usr/local/bin --filename=composer
        fi
        
        # Install PHP dependencies
        echo "Installing PHP dependencies..."
        composer install --no-dev --optimize-autoloader
        
        # Create .env file with database credentials
        echo "Creating .env file with database credentials..."
        if [ -f ".env.example" ]; then
          cp .env.example .env
          echo "Copied .env.example to .env"
        else
          cat > .env << 'ENVEOF'
        APP_NAME="PHP App"
        APP_ENV=production
        APP_DEBUG=false
        APP_URL=http://${{ steps.launch-instance.outputs.public_ip }}
        
        # Database Configuration
        DB_CONNECTION=mysql
        DB_HOST=127.0.0.1
        DB_PORT=3306
        DB_DATABASE=php_app_db
        DB_USERNAME=php_user
        DB_PASSWORD=php_password_123
        
        # Cache and Session Configuration
        CACHE_DRIVER=file
        SESSION_DRIVER=file
        QUEUE_DRIVER=sync
        
        # Mail Configuration (if needed)
        MAIL_MAILER=smtp
        MAIL_HOST=mailpit
        MAIL_PORT=1025
        MAIL_USERNAME=null
        MAIL_PASSWORD=null
        MAIL_ENCRYPTION=null
        MAIL_FROM_ADDRESS="hello@example.com"
        MAIL_FROM_NAME="${APP_NAME}"
        
        # Logging
        LOG_CHANNEL=stack
        LOG_DEPRECATIONS_CHANNEL=null
        LOG_LEVEL=debug
        
        # Redis (if needed)
        REDIS_HOST=127.0.0.1
        REDIS_PASSWORD=null
        REDIS_PORT=6379
        
        # Queue (if needed)
        QUEUE_CONNECTION=sync
        
        # Session and Cookie
        SESSION_LIFETIME=120
        SESSION_SECURE_COOKIE=false
        
        # Timezone
        APP_TIMEZONE=UTC
        ENVEOF
          echo "Created new .env file"
        fi
        
        # Display .env contents for verification (without sensitive data)
        echo "=== .env file created successfully ==="
        echo "Database: php_app_db"
        echo "Username: php_user"
        echo "Host: 127.0.0.1"
        echo "Port: 3306"
        echo "================================"
        
        # Test database connection with the new credentials
        echo "Testing database connection with new credentials..."
        if mysql -u php_user -pphp_password_123 -e "USE php_app_db; SELECT 'Database connection successful' as status;" 2>/dev/null; then
          echo "✓ Database connection test passed"
        else
          echo "✗ Database connection test failed"
          echo "Trying to troubleshoot..."
          
          # Check if MySQL service is running
          sudo systemctl status mysql --no-pager -l
          
          # Check if user exists
          sudo mysql -e "SELECT User, Host FROM mysql.user WHERE User='php_user';" 2>/dev/null || echo "Could not check users"
          
          # Try to recreate user if needed
          sudo mysql -e "DROP USER IF EXISTS 'php_user'@'localhost';" 2>/dev/null || true
          sudo mysql -e "CREATE USER 'php_user'@'localhost' IDENTIFIED BY 'php_password_123';" 2>/dev/null || true
          sudo mysql -e "GRANT ALL PRIVILEGES ON php_app_db.* TO 'php_user'@'localhost';" 2>/dev/null || true
          sudo mysql -e "FLUSH PRIVILEGES;" 2>/dev/null || true
          
          # Test again
          if mysql -u php_user -pphp_password_123 -e "USE php_app_db; SELECT 'Database connection successful' as status;" 2>/dev/null; then
            echo "✓ Database connection test passed after troubleshooting"
          else
            echo "✗ Database connection still failing"
            exit 1
          fi
        fi
        
        # Set proper permissions
        echo "Setting file permissions..."
        sudo chown -R www-data:www-data /var/www/html
        sudo chmod -R 755 /var/www/html
        
        # Set permissions for Laravel-specific directories if they exist
        if [ -d "/var/www/html/storage" ]; then
          echo "Setting storage directory permissions..."
          sudo chmod -R 775 /var/www/html/storage
        else
          echo "Storage directory not found (not a Laravel app or different structure)"
        fi
        
        if [ -d "/var/www/html/bootstrap/cache" ]; then
          echo "Setting bootstrap/cache directory permissions..."
          sudo chmod -R 775 /var/www/html/bootstrap/cache
        else
          echo "Bootstrap/cache directory not found (not a Laravel app or different structure)"
        fi
        
        # Set permissions for other common writable directories
        for dir in "logs" "cache" "tmp" "uploads" "public/uploads"; do
          if [ -d "/var/www/html/$dir" ]; then
            echo "Setting permissions for $dir directory..."
            sudo chmod -R 775 "/var/www/html/$dir"
          else
            echo "Creating $dir directory (common writable directory)"
            sudo mkdir -p "/var/www/html/$dir"
            sudo chown www-data:www-data "/var/www/html/$dir"
            sudo chmod 775 "/var/www/html/$dir"
          fi
        done
        
        # Generate application key if needed (Laravel-specific)
        if [ -f "artisan" ]; then
          echo "Laravel application detected, running Laravel commands..."
          php artisan key:generate --force
          php artisan config:cache
          php artisan route:cache
          php artisan view:cache
        else
          echo "No artisan file found (not a Laravel application)"
          echo "Skipping Laravel-specific commands"
        fi
        
        # Configure nginx
        echo "Configuring nginx..."
        sudo rm -f /etc/nginx/sites-enabled/default
        
        # Determine the correct root directory based on application type
        echo "=== DETERMINING NGINX ROOT DIRECTORY ==="
        
        # Check what's actually in the directories
        echo "Contents of /var/www/html:"
        ls -la /var/www/html/ | head -10
        
        if [ -d "/var/www/html/public" ]; then
          echo "Contents of /var/www/html/public:"
          ls -la /var/www/html/public/ | head -10
        fi
        
        # Smart root directory detection
        if [ -d "/var/www/html/public" ] && [ -f "/var/www/html/public/index.php" ]; then
          NGINX_ROOT="/var/www/html/public"
          echo "✓ Using Laravel-style public directory: $NGINX_ROOT (index.php found)"
        elif [ -d "/var/www/html/public" ] && [ -f "/var/www/html/public/index.html" ]; then
          NGINX_ROOT="/var/www/html/public"
          echo "✓ Using Laravel-style public directory: $NGINX_ROOT (index.html found)"
        elif [ -f "/var/www/html/index.php" ]; then
          NGINX_ROOT="/var/www/html"
          echo "✓ Using root directory: $NGINX_ROOT (index.php found)"
        elif [ -f "/var/www/html/index.html" ]; then
          NGINX_ROOT="/var/www/html"
          echo "✓ Using root directory: $NGINX_ROOT (index.html found)"
        else
          NGINX_ROOT="/var/www/html"
          echo "⚠️  No index file found, using default root: $NGINX_ROOT"
        fi
        
        echo "Final nginx root directory: $NGINX_ROOT"
        echo "=========================================="
        
        # Create a simple index.php if none exists in the determined root
        if [ ! -f "$NGINX_ROOT/index.php" ] && [ ! -f "$NGINX_ROOT/index.html" ]; then
          echo "Creating default index.php file in $NGINX_ROOT..."
          sudo tee "$NGINX_ROOT/index.php" > /dev/null << 'PHPEOF'
        <?php
        echo "<h1>PHP Application Deployed Successfully!</h1>";
        echo "<p>Server: " . $_SERVER['SERVER_SOFTWARE'] . "</p>";
        echo "<p>PHP Version: " . phpversion() . "</p>";
        echo "<p>Document Root: " . $_SERVER['DOCUMENT_ROOT'] . "</p>";
        echo "<p>Current Directory: " . getcwd() . "</p>";
        echo "<p>Script Path: " . __FILE__ . "</p>";
        echo "<h2>Directory Contents:</h2>";
        echo "<pre>";
        $files = scandir('.');
        foreach ($files as $file) {
            if ($file != '.' && $file != '..') {
                $type = is_dir($file) ? 'DIR' : 'FILE';
                echo "$type: $file\n";
            }
        }
        echo "</pre>";
        echo "<h2>Parent Directory Contents:</h2>";
        echo "<pre>";
        $files = scandir('..');
        foreach ($files as $file) {
            if ($file != '.' && $file != '..') {
                $type = is_dir($file) ? 'DIR' : 'FILE';
                echo "$type: $file\n";
            }
        }
        echo "</pre>";
        ?>
        PHPEOF
          sudo chown www-data:www-data "$NGINX_ROOT/index.php"
          sudo chmod 644 "$NGINX_ROOT/index.php"
          echo "✓ Default index.php created in $NGINX_ROOT"
        else
          echo "✓ Index file already exists in $NGINX_ROOT"
        fi
        
        sudo tee /etc/nginx/sites-available/php-app > /dev/null << 'NGINXEOF'
        server {
            listen 80 default_server;
            server_name _;
            root REPLACE_ROOT_PATH;
            index index.php index.html index.htm;
            
            # Enable access logging for debugging
            access_log /var/log/nginx/php-app-access.log;
            error_log /var/log/nginx/php-app-error.log;
            
            # Security headers
            add_header X-Frame-Options "SAMEORIGIN" always;
            add_header X-XSS-Protection "1; mode=block" always;
            add_header X-Content-Type-Options "nosniff" always;
            add_header Referrer-Policy "no-referrer-when-downgrade" always;
            add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
            
            # Handle PHP files
            location ~ \.php$ {
                try_files $uri =404;
                fastcgi_split_path_info ^(.+\.php)(/.+)$;
                fastcgi_pass unix:/var/run/php/php8.1-fpm.sock;
                fastcgi_index index.php;
                include fastcgi_params;
                fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                fastcgi_param PATH_INFO $fastcgi_path_info;
                
                # Enable error logging for PHP
                fastcgi_intercept_errors on;
            }
            
            # Handle static files
            location ~* \.(jpg|jpeg|png|gif|ico|css|js|pdf|txt)$ {
                expires 1y;
                add_header Cache-Control "public, immutable";
            }
            
            # Handle routes (Laravel-style or standard)
            location / {
                try_files $uri $uri/ /index.php?$query_string;
            }
            
            # Deny access to sensitive files
            location ~ /\. {
                deny all;
            }
            
            location ~ /\.ht {
                deny all;
            }
            
            location ~ /\.env {
                deny all;
            }
            
            location ~ /\.git {
                deny all;
            }
            
            # Custom error pages
            error_page 403 /403.html;
            error_page 404 /404.html;
            error_page 500 /500.html;
        }
        NGINXEOF
        
        # Replace the placeholder with actual root path
        sudo sed -i "s|REPLACE_ROOT_PATH|$NGINX_ROOT|g" /etc/nginx/sites-available/php-app
        
        # Verify the replacement worked
        echo "=== NGINX CONFIGURATION VERIFICATION ==="
        echo "Checking nginx configuration file:"
        sudo grep "root" /etc/nginx/sites-available/php-app
        
        # Enable the site
        sudo ln -sf /etc/nginx/sites-available/php-app /etc/nginx/sites-enabled/
        
        # Double-check the enabled site
        echo "Checking enabled site configuration:"
        sudo grep "root" /etc/nginx/sites-enabled/php-app
        
        echo "======================================="
        
        # Test nginx configuration
        sudo nginx -t
        
        # Reload nginx
        sudo systemctl reload nginx
        
        # Comprehensive troubleshooting and verification
        echo "=== TROUBLESHOOTING AND VERIFICATION ==="
        
        # Check nginx configuration
        echo "1. Nginx configuration test:"
        sudo nginx -t
        
        # Check nginx status
        echo "2. Nginx service status:"
        sudo systemctl status nginx --no-pager -l
        
        # Check PHP-FPM status
        echo "3. PHP-FPM service status:"
        sudo systemctl status php8.1-fpm --no-pager -l
        
        # Check file permissions
        echo "4. File permissions check:"
        echo "Root directory: $NGINX_ROOT"
        ls -la "$NGINX_ROOT" | head -10
        
        # Check if index file exists
        echo "5. Index file check:"
        if [ -f "$NGINX_ROOT/index.php" ]; then
          echo "✓ index.php exists at $NGINX_ROOT/index.php"
        elif [ -f "$NGINX_ROOT/index.html" ]; then
          echo "✓ index.html exists at $NGINX_ROOT/index.html"
        else
          echo "✗ No index file found in $NGINX_ROOT"
        fi
        
        # Check nginx error logs
        echo "6. Recent nginx error logs:"
        sudo tail -20 /var/log/nginx/error.log 2>/dev/null || echo "No error log found"
        
        # Check PHP-FPM logs
        echo "7. Recent PHP-FPM logs:"
        sudo tail -20 /var/log/php8.1-fpm.log 2>/dev/null || echo "No PHP-FPM log found"
        
        # Test local access
        echo "8. Testing local access:"
        if curl -s http://localhost > /dev/null; then
          echo "✓ Nginx responds locally"
          echo "Response content (first 500 chars):"
          curl -s http://localhost | head -c 500
          echo ""
        else
          echo "✗ Nginx doesn't respond locally"
          echo "Response:"
          curl -v http://localhost 2>&1 | head -20
        fi
        
        # Test the specific root directory
        echo "9. Testing root directory access:"
        echo "Current nginx root: $NGINX_ROOT"
        if [ -f "$NGINX_ROOT/index.php" ]; then
          echo "✓ Index file exists at $NGINX_ROOT/index.php"
          echo "File permissions:"
          ls -la "$NGINX_ROOT/index.php"
        else
          echo "✗ No index file found at $NGINX_ROOT/index.php"
        fi
        
        # Check PHP processing
        echo "10. Testing PHP processing:"
        if [ -f "$NGINX_ROOT/index.php" ]; then
          if php -l "$NGINX_ROOT/index.php" > /dev/null 2>&1; then
            echo "✓ PHP syntax is valid"
          else
            echo "✗ PHP syntax error in index.php"
            php -l "$NGINX_ROOT/index.php"
          fi
        fi
        
        # Check socket file
        echo "11. PHP-FPM socket check:"
        if [ -S "/var/run/php/php8.1-fpm.sock" ]; then
          echo "✓ PHP-FPM socket exists"
          ls -la /var/run/php/php8.1-fpm.sock
        else
          echo "✗ PHP-FPM socket not found"
        fi
        
        echo "=== END TROUBLESHOOTING ==="
        
        # Verify services are running
        echo "Verifying services..."
        sudo systemctl status nginx --no-pager -l
        sudo systemctl status php8.1-fpm --no-pager -l
        sudo systemctl status mysql --no-pager -l
        
        # Test PHP-FPM
        echo "Testing PHP-FPM..."
        if php -v > /dev/null 2>&1; then
          echo "✓ PHP is working"
        else
          echo "✗ PHP is not working"
          exit 1
        fi
        
        # Test MySQL connection
        echo "Testing MySQL connection..."
        if mysql -u php_user -pphp_password_123 -e "SELECT 1;" > /dev/null 2>&1; then
          echo "✓ MySQL connection is working"
        else
          echo "✗ MySQL connection is not working"
          exit 1
        fi
        
        # Test nginx
        echo "Testing nginx..."
        if curl -s http://localhost > /dev/null; then
          echo "✓ Nginx is responding"
        else
          echo "✗ Nginx is not responding"
          exit 1
        fi
        
        # Show final status
        echo "=== FINAL STATUS ==="
        echo "PHP version:"
        php -v
        echo ""
        echo "MySQL status:"
        sudo systemctl status mysql --no-pager -l
        echo ""
        echo "Nginx status:"
        sudo systemctl status nginx --no-pager -l
        echo ""
        echo "PHP-FPM status:"
        sudo systemctl status php8.1-fpm --no-pager -l
        echo "=== END STATUS ==="
        
        echo "PHP application deployment completed successfully!"
        echo "Application is running on:"
        echo "  HTTP:  http://${{ steps.launch-instance.outputs.public_ip }}"
        echo ""
        echo "Database credentials:"
        echo "  Database: php_app_db"
        echo "  Username: php_user"
        echo "  Password: php_password_123"
        echo "  Host: localhost"
        echo "  Port: 3306"
        DEPLOY_SCRIPT_EOF
        
        # Make script executable and run it
        chmod +x deploy-php.sh
        scp -i ${{ env.KEY_NAME }}.pem -o StrictHostKeyChecking=no deploy-php.sh ubuntu@${{ steps.launch-instance.outputs.public_ip }}:~/
        ssh -i ${{ env.KEY_NAME }}.pem -o StrictHostKeyChecking=no ubuntu@${{ steps.launch-instance.outputs.public_ip }} "chmod +x ~/deploy-php.sh && ~/deploy-php.sh"
        
    - name: Output deployment info
      run: |
        echo "🚀 PHP application deployment completed successfully!"
        echo "📱 Application URL: http://${{ steps.launch-instance.outputs.public_ip }}"
        echo "🔑 Instance ID: ${{ steps.launch-instance.outputs.instance_id }}"
        echo "🌍 Region: ${{ env.AWS_REGION }}"
        echo ""
        echo "Database Information:"
        echo "  Database: php_app_db"
        echo "  Username: php_user"
        echo "  Password: php_password_123"
        echo "  Host: localhost (on EC2 instance)"
        echo ""
        echo "To access your instance via SSH:"
        echo "ssh -i ${{ env.KEY_NAME }}.pem ubuntu@${{ steps.launch-instance.outputs.public_ip }}"
        
    - name: Cleanup key file
      if: always()
      run: rm -f ${{ env.KEY_NAME }}.pem

  cleanup:
    needs: deploy
    if: failure()
    runs-on: ubuntu-latest
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Cleanup EC2 instance
      if: needs.deploy.outputs.instance_id != ''
      run: |
        echo "Cleaning up EC2 instance due to job failure..."
        aws ec2 terminate-instances \
          --instance-ids ${{ needs.deploy.outputs.instance_id }} \
          --region ${{ env.AWS_REGION }}
        
        echo "Waiting for instance to terminate..."
        aws ec2 wait instance-terminated \
          --instance-ids ${{ needs.deploy.outputs.instance_id }} \
          --region ${{ env.AWS_REGION }}
        
        echo "EC2 instance terminated successfully"
        
    - name: Cleanup key pair
      if: always()
      run: |
        echo "Cleaning up key pair..."
        aws ec2 delete-key-pair \
          --key-name ${{ env.KEY_NAME }} \
          --region ${{ env.AWS_REGION }} || true
        
        echo "Key pair cleanup completed"
        
    - name: Cleanup security group
      if: always()
      run: |
        echo "Cleaning up security group..."
        aws ec2 delete-security-group \
          --group-name php-app-sg \
          --region ${{ env.AWS_REGION }} || true
        
        echo "Security group cleanup completed"
        
    - name: Cleanup completed
      run: echo "All cleanup operations completed"
